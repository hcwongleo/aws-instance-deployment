AWSTemplateFormatVersion: '2010-09-09'
Description: 'G5 instance with auto-termination'

Parameters:
  InstanceType:
    Type: String
    Default: g5.xlarge
    AllowedValues:
      - g5.xlarge
      - g5.2xlarge
      - g5.4xlarge
      - g5.8xlarge
      - g5.12xlarge
      - g5.16xlarge
      - g5.24xlarge
      - g5.48xlarge
    Description: "G5 instance type (g5.xlarge = $1.00/hr, g5.2xlarge = $1.21/hr, etc.)"
  
  KeyPairName:
    Type: String
    Default: ""
    Description: "EC2 Key Pair name for SSH access (optional - leave empty if not needed since SSM is available)"
  
  TerminationHours:
    Type: Number
    Default: 336
    MinValue: 1
    MaxValue: 8760
    Description: "Hours until auto-termination (336=14days, 168=7days, 24=1day, 2=testing)"

Conditions:
  HasKeyPair: !Not [!Equals [!Ref KeyPairName, ""]]

Resources:
  # Security Group
  G5SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for G5 instance - no ingress allowed
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-sg'

  # IAM Role for the instance
  G5InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-role'

  G5InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref G5InstanceRole

  # G5 Instance
  G5Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: ami-0c02fb55956c7d316  # Amazon Linux 2 AMI in us-east-1
      KeyName: !If [HasKeyPair, !Ref KeyPairName, !Ref "AWS::NoValue"]
      SecurityGroupIds:
        - !Ref G5SecurityGroup
      IamInstanceProfile: !Ref G5InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y nvidia-driver-latest-dkms
          yum install -y cuda-drivers
          
          # Install NVIDIA Docker
          distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
          curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo
          yum install -y nvidia-docker2
          systemctl restart docker
          
          # Instance setup complete - termination will be based on launch time + TerminationHours parameter
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-g5-instance'
        - Key: AutoTerminate
          Value: 'true'
        - Key: CreatedDate
          Value: !Sub '${AWS::StackName}-created'

  # Lambda function for auto-termination
  AutoTerminationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: EC2TerminationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ec2:TerminateInstances
                  - ec2:DescribeTags
                Resource: '*'

  AutoTerminationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-auto-termination'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt AutoTerminationRole.Arn
      Timeout: 300
      Environment:
        Variables:
          TERMINATION_HOURS: !Ref TerminationHours
      Code:
        ZipFile: |
          import boto3
          import json
          from datetime import datetime, timezone, timedelta
          
          def lambda_handler(event, context):
              print(f"=== AUTO-TERMINATION LAMBDA STARTED ===")
              print(f"Event: {json.dumps(event, default=str)}")
              print(f"Context: {context}")
              print(f"Function name: {context.function_name}")
              print(f"Request ID: {context.aws_request_id}")
              
              ec2 = boto3.client('ec2')
              current_datetime = datetime.now(timezone.utc)
              print(f"Current UTC datetime: {current_datetime}")
              
              # Get instances with AutoTerminate tag
              print("Searching for instances with AutoTerminate=true tag...")
              try:
                  response = ec2.describe_instances(
                      Filters=[
                          {'Name': 'tag:AutoTerminate', 'Values': ['true']},
                          {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
                      ]
                  )
                  print(f"Found {len(response['Reservations'])} reservations")
              except Exception as e:
                  print(f"ERROR: Failed to describe instances: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
              
              instances_to_terminate = []
              all_instances_found = []
              
              for reservation in response['Reservations']:
                  print(f"Processing reservation: {reservation['ReservationId']}")
                  for instance in reservation['Instances']:
                      instance_id = instance['InstanceId']
                      instance_state = instance['State']['Name']
                      instance_type = instance.get('InstanceType', 'unknown')
                      launch_time = instance.get('LaunchTime', 'unknown')
                      all_instances_found.append(instance_id)
                      
                      print(f"  Instance {instance_id} (type: {instance_type}, state: {instance_state}, launched: {launch_time})")
                      
                      # Print all tags for debugging
                      tags = instance.get('Tags', [])
                      print(f"    All tags ({len(tags)} total):")
                      for tag in tags:
                          print(f"      {tag['Key']}: {tag['Value']}")
                      
                      # Check for AutoTerminate tag specifically
                      auto_terminate_found = False
                      for tag in tags:
                          if tag['Key'] == 'AutoTerminate':
                              auto_terminate_found = True
                              print(f"    ✓ AutoTerminate tag found: {tag['Value']}")
                              break
                      
                      if not auto_terminate_found:
                          print(f"    WARNING: AutoTerminate tag not found for instance {instance_id}")
                      
                      # Calculate termination time from launch time + TerminationHours parameter
                      import os
                      termination_hours = int(os.environ.get('TERMINATION_HOURS', '336'))
                      print(f"    Calculating termination time from launch time + {termination_hours} hours")
                      
                      launch_time = instance.get('LaunchTime')
                      if launch_time:
                          # Convert launch_time to UTC datetime if it's not already
                          if hasattr(launch_time, 'replace'):
                              launch_datetime = launch_time.replace(tzinfo=timezone.utc)
                          else:
                              launch_datetime = launch_time
                          
                          # Add TerminationHours parameter to launch time
                          termination_datetime = launch_datetime + timedelta(hours=termination_hours)
                          print(f"    Launch time: {launch_datetime}")
                          print(f"    Calculated termination time: {termination_datetime}")
                      else:
                          print(f"    ERROR: No launch time found for instance {instance_id}")
                          continue
                      
                      # Compare times
                      print(f"    Time comparison:")
                      print(f"      Current time:     {current_datetime}")
                      print(f"      Termination time: {termination_datetime}")
                      
                      time_diff = (termination_datetime - current_datetime).total_seconds()
                      hours_diff = time_diff / 3600
                      
                      print(f"      Time difference: {time_diff:.0f} seconds ({hours_diff:.2f} hours)")
                      
                      if current_datetime >= termination_datetime:
                          instances_to_terminate.append(instance_id)
                          print(f"    ✓ TERMINATION REQUIRED: Instance {instance_id} expired {-hours_diff:.2f} hours ago")
                      else:
                          print(f"    ✗ NOT READY: Instance {instance_id} expires in {hours_diff:.2f} hours")
              
              print(f"\n=== SUMMARY ===")
              print(f"Total reservations found: {len(response['Reservations'])}")
              print(f"Total instances found: {len(all_instances_found)}")
              print(f"Instances to terminate: {len(instances_to_terminate)}")
              print(f"Instance IDs found: {all_instances_found}")
              print(f"Instance IDs to terminate: {instances_to_terminate}")
              
              # Terminate instances
              if instances_to_terminate:
                  try:
                      print(f"\nAttempting to terminate {len(instances_to_terminate)} instances...")
                      for instance_id in instances_to_terminate:
                          print(f"  Terminating: {instance_id}")
                      
                      terminate_response = ec2.terminate_instances(InstanceIds=instances_to_terminate)
                      print(f"Termination API response: {json.dumps(terminate_response, default=str)}")
                      
                      # Check termination status
                      terminating_instances = terminate_response.get('TerminatingInstances', [])
                      for term_instance in terminating_instances:
                          instance_id = term_instance['InstanceId']
                          current_state = term_instance['CurrentState']['Name']
                          previous_state = term_instance['PreviousState']['Name']
                          print(f"  ✓ {instance_id}: {previous_state} → {current_state}")
                      
                      print(f"✓ Successfully initiated termination for {len(instances_to_terminate)} instances")
                      
                  except Exception as e:
                      print(f"ERROR: Failed to terminate instances: {str(e)}")
                      print(f"Error type: {type(e).__name__}")
                      return {
                          'statusCode': 500, 
                          'body': json.dumps({
                              'error': str(e),
                              'instances_found': all_instances_found,
                              'instances_to_terminate': instances_to_terminate
                          })
                      }
              else:
                  print("No instances require termination at this time")
              
              result = {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': f'Processed {len(instances_to_terminate)} instances for termination',
                      'instances_found': all_instances_found,
                      'instances_terminated': instances_to_terminate,
                      'current_time': str(current_datetime),
                      'total_reservations': len(response['Reservations']),
                      'total_instances': len(all_instances_found)
                  })
              }
              
              print(f"\n=== AUTO-TERMINATION LAMBDA COMPLETED ===")
              print(f"Final result: {json.dumps(result, indent=2)}")
              return result

  # EventBridge rule to trigger Lambda hourly
  AutoTerminationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Hourly check for instances to auto-terminate'
      ScheduleExpression: 'rate(1 hour)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt AutoTerminationFunction.Arn
          Id: AutoTerminationTarget

  # Permission for EventBridge to invoke Lambda
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AutoTerminationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt AutoTerminationSchedule.Arn



Outputs:
  InstanceId:
    Description: 'G5 Instance ID'
    Value: !Ref G5Instance
    Export:
      Name: !Sub '${AWS::StackName}-InstanceId'
  
  PublicIP:
    Description: 'Public IP of the G5 instance'
    Value: !GetAtt G5Instance.PublicIp
    Export:
      Name: !Sub '${AWS::StackName}-PublicIP'
  
  PrivateIP:
    Description: 'Private IP of the G5 instance'
    Value: !GetAtt G5Instance.PrivateIp
    Export:
      Name: !Sub '${AWS::StackName}-PrivateIP'
  
  AutoTerminationFunctionName:
    Description: 'Auto-termination Lambda function name'
    Value: !Ref AutoTerminationFunction
    Export:
      Name: !Sub '${AWS::StackName}-AutoTerminationFunction'