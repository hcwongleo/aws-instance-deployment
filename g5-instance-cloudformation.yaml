AWSTemplateFormatVersion: '2010-09-09'
Description: 'G5 instance with auto-termination after 2 weeks'

Parameters:
  InstanceType:
    Type: String
    Default: g5.xlarge
    AllowedValues:
      - g5.xlarge
      - g5.2xlarge
      - g5.4xlarge
      - g5.8xlarge
      - g5.12xlarge
      - g5.16xlarge
      - g5.24xlarge
      - g5.48xlarge
    Description: "G5 instance type (g5.xlarge = $1.00/hr, g5.2xlarge = $1.21/hr, etc.)"
  
  KeyPairName:
    Type: String
    Default: ""
    Description: "EC2 Key Pair name for SSH access (optional - leave empty if not needed since SSM is available)"
  
  TerminationHours:
    Type: Number
    Default: 336
    MinValue: 1
    MaxValue: 8760
    Description: "Hours until auto-termination (336=14days, 168=7days, 24=1day, 2=testing)"

Conditions:
  HasKeyPair: !Not [!Equals [!Ref KeyPairName, ""]]

Resources:
  # Security Group
  G5SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for G5 instance - no ingress allowed
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-sg'

  # IAM Role for the instance
  G5InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-role'

  G5InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref G5InstanceRole

  # G5 Instance
  G5Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: ami-0c02fb55956c7d316  # Amazon Linux 2 AMI in us-east-1
      KeyName: !If [HasKeyPair, !Ref KeyPairName, !Ref "AWS::NoValue"]
      SecurityGroupIds:
        - !Ref G5SecurityGroup
      IamInstanceProfile: !Ref G5InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y nvidia-driver-latest-dkms
          yum install -y cuda-drivers
          
          # Install NVIDIA Docker
          distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
          curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo
          yum install -y nvidia-docker2
          systemctl restart docker
          
          # Set termination datetime based on parameter (hours)
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
          TERMINATION_DATETIME=$(date -d "+${TerminationHours} hours" '+%Y-%m-%d %H:%M:%S')
          aws ec2 create-tags --region ${AWS::Region} --resources $INSTANCE_ID --tags Key=TerminationDateTime,Value="$TERMINATION_DATETIME"
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-g5-instance'
        - Key: AutoTerminate
          Value: 'true'
        - Key: CreatedDate
          Value: !Sub '${AWS::StackName}-created'

  # Lambda function for auto-termination
  AutoTerminationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: EC2TerminationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ec2:TerminateInstances
                  - ec2:DescribeTags
                Resource: '*'

  AutoTerminationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-auto-termination'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt AutoTerminationRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          from datetime import datetime, timezone
          
          def lambda_handler(event, context):
              print(f"=== AUTO-TERMINATION LAMBDA STARTED ===")
              print(f"Event: {json.dumps(event, default=str)}")
              print(f"Context: {context}")
              
              ec2 = boto3.client('ec2')
              current_datetime = datetime.now(timezone.utc)
              print(f"Current UTC datetime: {current_datetime}")
              
              # Get instances with AutoTerminate tag
              print("Searching for instances with AutoTerminate=true tag...")
              try:
                  response = ec2.describe_instances(
                      Filters=[
                          {'Name': 'tag:AutoTerminate', 'Values': ['true']},
                          {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
                      ]
                  )
                  print(f"Found {len(response['Reservations'])} reservations")
              except Exception as e:
                  print(f"ERROR: Failed to describe instances: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
              
              instances_to_terminate = []
              all_instances_found = []
              
              for reservation in response['Reservations']:
                  print(f"Processing reservation: {reservation['ReservationId']}")
                  for instance in reservation['Instances']:
                      instance_id = instance['InstanceId']
                      instance_state = instance['State']['Name']
                      all_instances_found.append(instance_id)
                      
                      print(f"  Instance {instance_id} (state: {instance_state})")
                      
                      # Print all tags for debugging
                      tags = instance.get('Tags', [])
                      print(f"    Tags: {tags}")
                      
                      # Check termination datetime tag
                      termination_datetime = None
                      termination_datetime_str = None
                      
                      for tag in tags:
                          if tag['Key'] == 'TerminationDateTime':
                              termination_datetime_str = tag['Value']
                              print(f"    Found TerminationDateTime tag: {termination_datetime_str}")
                              try:
                                  termination_datetime = datetime.strptime(termination_datetime_str, '%Y-%m-%d %H:%M:%S').replace(tzinfo=timezone.utc)
                                  print(f"    Parsed termination datetime: {termination_datetime}")
                              except ValueError as e:
                                  print(f"    ERROR: Failed to parse datetime '{termination_datetime_str}': {str(e)}")
                                  continue
                              break
                      
                      if not termination_datetime_str:
                          print(f"    WARNING: No TerminationDateTime tag found for instance {instance_id}")
                          continue
                      
                      if not termination_datetime:
                          print(f"    WARNING: Could not parse TerminationDateTime for instance {instance_id}")
                          continue
                      
                      print(f"    Comparing: current={current_datetime} vs termination={termination_datetime}")
                      time_diff = (termination_datetime - current_datetime).total_seconds()
                      print(f"    Time difference: {time_diff} seconds ({time_diff/3600:.2f} hours)")
                      
                      if current_datetime >= termination_datetime:
                          instances_to_terminate.append(instance_id)
                          print(f"    ✓ Instance {instance_id} scheduled for termination (expired {-time_diff/3600:.2f} hours ago)")
                      else:
                          print(f"    ✗ Instance {instance_id} not ready for termination (expires in {time_diff/3600:.2f} hours)")
              
              print(f"Summary:")
              print(f"  Total instances found: {len(all_instances_found)}")
              print(f"  Instances to terminate: {len(instances_to_terminate)}")
              print(f"  Instance IDs found: {all_instances_found}")
              print(f"  Instance IDs to terminate: {instances_to_terminate}")
              
              # Terminate instances
              if instances_to_terminate:
                  try:
                      print(f"Attempting to terminate instances: {instances_to_terminate}")
                      terminate_response = ec2.terminate_instances(InstanceIds=instances_to_terminate)
                      print(f"Termination response: {terminate_response}")
                      print(f"✓ Successfully initiated termination for instances: {instances_to_terminate}")
                  except Exception as e:
                      print(f"ERROR: Failed to terminate instances: {str(e)}")
                      return {'statusCode': 500, 'body': f'Termination failed: {str(e)}'}
              else:
                  print("No instances to terminate at this time")
              
              result = {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': f'Processed {len(instances_to_terminate)} instances for termination',
                      'instances_found': all_instances_found,
                      'instances_terminated': instances_to_terminate,
                      'current_time': str(current_datetime)
                  })
              }
              
              print(f"=== AUTO-TERMINATION LAMBDA COMPLETED ===")
              print(f"Result: {result}")
              return result

  # EventBridge rule to trigger Lambda hourly
  AutoTerminationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Hourly check for instances to auto-terminate'
      ScheduleExpression: 'rate(1 hour)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt AutoTerminationFunction.Arn
          Id: AutoTerminationTarget

  # Permission for EventBridge to invoke Lambda
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AutoTerminationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt AutoTerminationSchedule.Arn

  # Manual invoke function for debugging
  ManualInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: InvokeLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt AutoTerminationFunction.Arn

  ManualInvokeFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-manual-invoke'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ManualInvokeRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          
          def lambda_handler(event, context):
              lambda_client = boto3.client('lambda')
              
              # Get the auto-termination function name from environment or event
              function_name = event.get('function_name', context.function_name.replace('-manual-invoke', '-auto-termination'))
              
              print(f"Manually invoking function: {function_name}")
              
              try:
                  response = lambda_client.invoke(
                      FunctionName=function_name,
                      InvocationType='RequestResponse',
                      Payload=json.dumps({'source': 'manual-invoke'})
                  )
                  
                  payload = json.loads(response['Payload'].read())
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Successfully invoked auto-termination function',
                          'response': payload
                      })
                  }
              except Exception as e:
                  print(f"Error invoking function: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e)
                      })
                  }

Outputs:
  InstanceId:
    Description: 'G5 Instance ID'
    Value: !Ref G5Instance
    Export:
      Name: !Sub '${AWS::StackName}-InstanceId'
  
  PublicIP:
    Description: 'Public IP of the G5 instance'
    Value: !GetAtt G5Instance.PublicIp
    Export:
      Name: !Sub '${AWS::StackName}-PublicIP'
  
  PrivateIP:
    Description: 'Private IP of the G5 instance'
    Value: !GetAtt G5Instance.PrivateIp
    Export:
      Name: !Sub '${AWS::StackName}-PrivateIP'
  
  AutoTerminationFunctionName:
    Description: 'Auto-termination Lambda function name'
    Value: !Ref AutoTerminationFunction
    Export:
      Name: !Sub '${AWS::StackName}-AutoTerminationFunction'
  
  ManualInvokeFunctionName:
    Description: 'Manual invoke Lambda function name (use this to test auto-termination)'
    Value: !Ref ManualInvokeFunction
    Export:
      Name: !Sub '${AWS::StackName}-ManualInvokeFunction'